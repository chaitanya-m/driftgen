From 17be5d365c11a0d70b2ed004c625409a3e809530 Mon Sep 17 00:00:00 2001
From: Chaitanya Manapragada <cman39@student.monash.edu.au>
Date: Mon, 5 Jun 2017 10:26:51 +1000
Subject: [PATCH 25/27] Proof of "null parent" bug

This is self-explanatory. With subtree substitution turned off,  null parent confuses root and it's alternate. As long as an alternate is created at root, it gets substituted in even with subtree promotion turned off.

Attempt to split was taken directly from HoeffdingTree.java

                   		System.err.println("Tree Root has already been split. So it must be the root's alternate that is being set to root here... in the split function!!!"
                    				+ "Because parent is null");

EvaluatePrequential -l trees.HATADWINOriginal -s (generators.monash.AbruptDriftGenerator -o 0.800001 -c -z 5 -n 5 -v 5 -r 1 -i 0.800001 -b 200000) -i 400000 -f 1000
---
 src/moa/classifiers/trees/HATADWINOriginal.java | 106 +++++++++++++++++++++++-
 1 file changed, 105 insertions(+), 1 deletion(-)

diff --git a/src/moa/classifiers/trees/HATADWINOriginal.java b/src/moa/classifiers/trees/HATADWINOriginal.java
index 1673ee4..4b6d4ba 100644
--- a/src/moa/classifiers/trees/HATADWINOriginal.java
+++ b/src/moa/classifiers/trees/HATADWINOriginal.java
@@ -19,12 +19,20 @@
  */
 package moa.classifiers.trees;
 
+import java.util.Arrays;
+import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Random;
+import java.util.Set;
+
 import moa.classifiers.bayes.NaiveBayes;
+import moa.classifiers.core.AttributeSplitSuggestion;
 import moa.classifiers.core.conditionaltests.InstanceConditionalTest;
 import moa.classifiers.core.driftdetection.ADWIN;
+import moa.classifiers.core.splitcriteria.SplitCriterion;
+import moa.classifiers.trees.HoeffdingTree.ActiveLearningNode;
+import moa.classifiers.trees.HoeffdingTree.SplitNode;
 import moa.core.DoubleVector;
 import moa.core.MiscUtils;
 import moa.core.Utils;
@@ -55,6 +63,8 @@ public class HATADWINOriginal extends HoeffdingTree {
 
     private static final long serialVersionUID = 1L;
 
+    private static long numInstances = 0;
+
     @Override
     public String getPurposeString() {
         return "Hoeffding Adaptive Tree for evolving data streams that uses ADWIN to replace branches for new ones.";
@@ -167,6 +177,9 @@ public class HATADWINOriginal extends HoeffdingTree {
         // SplitNodes can have alternative trees, but LearningNodes can't
         // LearningNodes can split, but SplitNodes can't
         // Parent nodes are allways SplitNodes
+        /* (non-Javadoc)
+         * @see moa.classifiers.trees.HATADWINOriginal.NewNode#learnFromInstance(com.yahoo.labs.samoa.instances.Instance, moa.classifiers.trees.HATADWINOriginal, moa.classifiers.trees.HoeffdingTree.SplitNode, int)
+         */
         @Override
         public void learnFromInstance(Instance inst, HATADWINOriginal ht, SplitNode parent, int parentBranch) {
             int trueClass = (int) inst.classValue();
@@ -212,7 +225,11 @@ public class HATADWINOriginal extends HoeffdingTree {
                     double fN = 1.0 / (((NewNode) this.alternateTree).getErrorWidth()) + 1.0 / (this.getErrorWidth());
                     double Bound = Math.sqrt(2.0 * oldErrorRate * (1.0 - oldErrorRate) * Math.log(2.0 / fDelta) * fN);
 
-                    if (Bound < oldErrorRate - altErrorRate) {
+                    System.out.println(this.alternateTree.subtreeDepth() + " " + this.subtreeDepth() + " " + (parent==null));
+
+                    if (Bound < oldErrorRate - altErrorRate
+                    		&& this.subtreeDepth() < 0
+                    		) {
                         // Switch alternate tree
                         ht.activeLeafNodeCount -= this.numberLeaves();
                         ht.activeLeafNodeCount += ((NewNode) this.alternateTree).numberLeaves();
@@ -482,7 +499,94 @@ public class HATADWINOriginal extends HoeffdingTree {
     }
 
     @Override
+	protected void attemptToSplit(ActiveLearningNode node, SplitNode parent,
+            int parentIndex) {
+        if (!node.observedClassDistributionIsPure()) {
+            SplitCriterion splitCriterion = (SplitCriterion) getPreparedClassOption(this.splitCriterionOption);
+            AttributeSplitSuggestion[] bestSplitSuggestions = node.getBestSplitSuggestions(splitCriterion, this);
+            Arrays.sort(bestSplitSuggestions);
+            boolean shouldSplit = false;
+            if (bestSplitSuggestions.length < 2) {
+                shouldSplit = bestSplitSuggestions.length > 0;
+            } else {
+                double hoeffdingBound = computeHoeffdingBound(splitCriterion.getRangeOfMerit(node.getObservedClassDistribution()),
+                        this.splitConfidenceOption.getValue(), node.getWeightSeen());
+                AttributeSplitSuggestion bestSuggestion = bestSplitSuggestions[bestSplitSuggestions.length - 1];
+                AttributeSplitSuggestion secondBestSuggestion = bestSplitSuggestions[bestSplitSuggestions.length - 2];
+                if ((bestSuggestion.merit - secondBestSuggestion.merit > hoeffdingBound)
+                        || (hoeffdingBound < this.tieThresholdOption.getValue())) {
+                    shouldSplit = true;
+                }
+                // }
+                if ((this.removePoorAttsOption != null)
+                        && this.removePoorAttsOption.isSet()) {
+                    Set<Integer> poorAtts = new HashSet<Integer>();
+                    // scan 1 - add any poor to set
+                    for (int i = 0; i < bestSplitSuggestions.length; i++) {
+                        if (bestSplitSuggestions[i].splitTest != null) {
+                            int[] splitAtts = bestSplitSuggestions[i].splitTest.getAttsTestDependsOn();
+                            if (splitAtts.length == 1) {
+                                if (bestSuggestion.merit
+                                        - bestSplitSuggestions[i].merit > hoeffdingBound) {
+                                    poorAtts.add(new Integer(splitAtts[0]));
+                                }
+                            }
+                        }
+                    }
+                    // scan 2 - remove good ones from set
+                    for (int i = 0; i < bestSplitSuggestions.length; i++) {
+                        if (bestSplitSuggestions[i].splitTest != null) {
+                            int[] splitAtts = bestSplitSuggestions[i].splitTest.getAttsTestDependsOn();
+                            if (splitAtts.length == 1) {
+                                if (bestSuggestion.merit
+                                        - bestSplitSuggestions[i].merit < hoeffdingBound) {
+                                    poorAtts.remove(new Integer(splitAtts[0]));
+                                }
+                            }
+                        }
+                    }
+                    for (int poorAtt : poorAtts) {
+                        node.disableAttribute(poorAtt);
+                    }
+                }
+            }
+            if (shouldSplit) {
+                AttributeSplitSuggestion splitDecision = bestSplitSuggestions[bestSplitSuggestions.length - 1];
+                if (splitDecision.splitTest == null) {
+                    // preprune - null wins
+                    deactivateLearningNode(node, parent, parentIndex);
+                } else {
+                    SplitNode newSplit = newSplitNode(splitDecision.splitTest,
+                            node.getObservedClassDistribution(),splitDecision.numSplits() );
+                    for (int i = 0; i < splitDecision.numSplits(); i++) {
+                        Node newChild = newLearningNode(splitDecision.resultingClassDistributionFromSplit(i));
+                        newSplit.setChild(i, newChild);
+                    }
+                    this.activeLeafNodeCount--;
+                    this.decisionNodeCount++;
+                    this.activeLeafNodeCount += splitDecision.numSplits();
+                    if (parent == null) {
+                    	if(this.treeRoot.getClass() != AdaLearningNode.class){
+                    		System.err.println("Tree Root has already been split. So it must be the root's alternate that is being set to root here... in the split function!!!"
+                    				+ "Because parent is null");
+                    	}
+
+                        this.treeRoot = newSplit;
+                    } else {
+                        parent.setChild(parentIndex, newSplit);
+                    }
+                }
+                // manage memory
+                enforceTrackerLimit();
+            }
+        }
+    }
+
+
+    @Override
     public double[] getVotesForInstance(Instance inst) {
+    	numInstances++;
+
         if (this.treeRoot != null) {
             FoundNode[] foundNodes = filterInstanceToLeaves(inst,
                     null, -1, false);
-- 
2.7.4

