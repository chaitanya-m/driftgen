From 0f00948a2559e5275b1109ba7cd434cd24b0a21d Mon Sep 17 00:00:00 2001
From: Chaitanya Manapragada <cman39@student.monash.edu.au>
Date: Sat, 3 Jun 2017 14:06:06 +1000
Subject: [PATCH 19/27] Recovery after drift (ie in spite of alternate
 learning)

A number of changes over this commit and the last enable this.

First, resolving any confusion  between root and root's alternate in the split function. The check used to be if parent was null. Since learnFromInstance would've had root's alternate in with null parent, the mainline tree would be lost in the splitting process without an alternate promotion ever happening. This would of course destroy prediction. It was the lack of clear distinction between mainline and alternate nodes that allowed the old code to work even if the alternates took over with no promotion.

This fix alone restarts learning after the drift. It doesn't yet fully approximate VFDT with promotion turned off, we'll get there one step at a time.

I also created a way for alternate subtrees to attach to the mainline. Only the point of attachment is recorded.Any node with no attachment doesn't have to carry information about the attachment it is forked from- only the top alternate node and it's corresponding mainline node need to.

This fixes the -999 check issue that only worked one level down. This fix is still commented out, but it will be uncommented in the next commit.
---
 src/moa/classifiers/trees/HATADWIN.java | 41 ++++++++++++++++++++++++++++-----
 1 file changed, 35 insertions(+), 6 deletions(-)

diff --git a/src/moa/classifiers/trees/HATADWIN.java b/src/moa/classifiers/trees/HATADWIN.java
index 6c7405c..c6bf3e6 100644
--- a/src/moa/classifiers/trees/HATADWIN.java
+++ b/src/moa/classifiers/trees/HATADWIN.java
@@ -36,7 +36,6 @@ import moa.classifiers.trees.HoeffdingTree.ActiveLearningNode;
 import moa.classifiers.trees.HoeffdingTree.LearningNode;
 import moa.classifiers.trees.HoeffdingTree.Node;
 import moa.classifiers.trees.HoeffdingTree.SplitNode;
-import moa.classifiers.trees.SubConceptTree.NewNode;
 import moa.core.DoubleVector;
 import moa.core.MiscUtils;
 import moa.core.Utils;
@@ -106,6 +105,10 @@ public class HATADWIN extends HoeffdingTree {
 
 		public void setRoot(boolean isRoot);
 
+		public void setMainlineNode(AdaSplitNode parent);
+
+		public AdaSplitNode getMainlineNode();
+
     }
 
     public static class AdaSplitNode extends SplitNode implements NewNode {
@@ -127,6 +130,8 @@ public class HATADWIN extends HoeffdingTree {
 
         private boolean isRoot = false;
 
+		private AdaSplitNode mainlineNode = null; //null by default unless there is an attachment point
+
 		@Override
 		public boolean isAlternate() {
 			return this.isAlternate;
@@ -251,6 +256,7 @@ public class HATADWIN extends HoeffdingTree {
 
                 //Start a new alternative tree : learning node
                 this.alternateTree = ht.newLearningNode(true); // isAlternate is set to true
+                ((NewNode)this.alternateTree).setMainlineNode(this);
                 ht.alternateTrees++;
             } // Check condition to replace tree
 
@@ -371,6 +377,16 @@ public class HATADWIN extends HoeffdingTree {
 			this.isRoot = isRoot;
 
 		}
+
+		@Override
+		public void setMainlineNode(AdaSplitNode mainlineNode) {
+			this.mainlineNode  = mainlineNode;
+		}
+
+		@Override
+		public AdaSplitNode getMainlineNode() {
+			return this.mainlineNode;
+		}
     }
 
     public static class AdaLearningNode extends LearningNodeNBAdaptive implements NewNode {
@@ -389,6 +405,8 @@ public class HATADWIN extends HoeffdingTree {
 
 		private boolean isRoot = false;
 
+		private AdaSplitNode mainlineNode = null; //null by default unless there is an attachment point
+
 		@Override
 		public boolean isAlternate() {
 			return this.isAlternate;
@@ -545,6 +563,16 @@ public class HATADWIN extends HoeffdingTree {
 			this.isRoot = isRoot;
 
 		}
+		@Override
+		public void setMainlineNode(AdaSplitNode mainlineNode) {
+			this.mainlineNode  = mainlineNode;
+		}
+
+		@Override
+		public AdaSplitNode getMainlineNode() {
+			return this.mainlineNode;
+		}
+
     }
 
     protected int alternateTrees;
@@ -678,12 +706,13 @@ public class HATADWIN extends HoeffdingTree {
                     if (((NewNode)node).isRoot()) {
                     	((NewNode)newSplit).setRoot(true);
                         this.treeRoot = newSplit;
-                        // What if I had an alternate at the root level? Parent would be null still, and treeRoot would be set to the alternate's split
-                        // This should resolve clearly the difference between root and root's alternate which would've shared parent null.
-                    } else {
+                    }
+                    else if (((NewNode)node).getMainlineNode() != null) { // if the node happens to have a mainline attachment
+                    	//((NewNode)node).getMainlineNode().alternateTree = newSplit;
+                    }
+                    else {
                         parent.setChild(parentIndex, newSplit);
-                        // but now... what happens when root's alternate is here? it's parent is null...
-                        // it must be attached to the root node... so let an alternate subtree be attached to a mainline node.
+
                     }
                 }
                 // manage memory
-- 
2.7.4

